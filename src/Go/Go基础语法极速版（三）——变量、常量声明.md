## 变量声明 `var`

在Go语言中，变量声明使用关键字`var`。它的基本语法是`var name type = value`，其中`name`是变量的名称，`type`是变量的类型，`value`是变量的初始值（可选）。下面我们将介绍一些与变量声明相关的概念和案例。

1.  局部变量：

    局部变量是在函数内部声明的变量，其作用域仅限于声明它的函数。它们只能在函数内部访问，其他函数无法直接访问这些变量。例如：

    ```go
    func foo() {
        var x int = 10
        fmt.Println(x) // 输出：10
    }

    func main() {
        // 无法访问变量x
        foo()
    }
    ```

2.  包变量：

    包变量是在函数外部、包内部声明的变量，它们可以在整个包内的任何函数中访问。这些变量在包级别可见。例如：

    ```go
    package main

    import "fmt"

    var x int = 10

    func foo() {
        fmt.Println(x) // 输出：10
    }

    func main() {
        foo()
        fmt.Println(x) // 输出：10
    }
    ```

3.  块声明：

    在Go语言中，可以使用块声明来定义一组变量。块声明是一种将多个变量声明在一起的简洁方式。例如：

    ```go
    func foo() {
        var (
            x int = 10
            y int = 20
            z int = 30
        )
        fmt.Println(x, y, z) // 输出：10 20 30
    }
    ```

4.  访问性控制：

    在Go语言中，变量的访问性由其名称的首字母大小写决定。如果变量名的首字母大写，表示该变量在包外可访问；如果变量名的首字母小写，表示该变量只在包内可访问。

5.  类型推断：

    Go语言支持类型推断，即可以根据变量的初始值自动推断其类型，无需显式指定类型。例如：

    ```go
    func main() {
        var x = 10       // 类型推断为int
        var y = "hello"  // 类型推断为string
        var z = 3.14    // 类型推断为float64
    }
    ```

## 变量声明 `:=`

在Go语言中，还有一种简化的变量声明方式，使用`:=`操作符，也称为短变量声明。这种方式只能用于局部变量，即方法内部，不能用于包变量或全局变量：

1.  类型推断：
    使用`:=`声明变量时，Go语言会根据变量的初始值自动推断其类型。整数会被推断为`int`，浮点数会被推断为`float64`。因此，如果想声明其他类型的数值，仍需使用`var`进行显式声明。

2.  简化语法：
    `:=`操作符是一种简化的语法，同时完成了变量声明和初始化的过程。不需要显式地指定变量的类型，编译器会根据初始值进行类型推断。

下面是一个使用`:=`声明局部变量的例子：

```go
func main() {
    x := 10 // 类型推断为int
    y := 3.14 // 类型推断为float64
    z := "hello" // 类型推断为string
    fmt.Println(x, y, z)
}
```

在上述例子中，变量`x`被推断为`int`类型，变量`y`被推断为`float64`类型，变量`z`被推断为`string`类型。需要注意的是，`:=`操作符只能用于局部变量的声明。如果要声明包级变量或全局变量，仍需使用`var`关键字进行显式声明。

### 变量声明易错点

*   在代码中声明了变量但未使用，这可能会导致编译错误。为了避免这种情况，建议只声明需要使用的变量，或者使用匿名变量。
*   在变量声明时，如果初始值的类型与变量声明的类型不匹配，会导致编译错误。确保变量的初始值与声明的类型相匹配，或者使用类型转换来进行匹配。
*   在同一个作用域下（如函数内部），变量名不能重复声明。如果在同一作用域内重复声明变量，会导致编译错误。确保变量名在同一作用域内是唯一的。

## 常量声明 const

与变量不同，常量是不可变的值，常用于定义程序运行期间保持不变的值。常量的声明方式与变量类似，只需用`const`替代`var`关键字，**在定义常量时必须进行赋值**。

常量只能存储以下数据类型之一：

*   布尔型
*   数字型（整数型、浮点型和复数）
*   字符串型

当使用未指定类型的常量时，其类型会根据上下文进行推断。换句话说，未定义类型的常量会根据需要自动获取相关类型。

```go
var n int
f(n + 5)    // 无类型的数字型常量 “5” 它的类型在这里变成了 int
```

### 常量使用规范

常量的值必须是能够在编译时就能确定的；你可以在其赋值表达式中涉及计算过程，但是所有用于计算的值必须在编译期间就能获得。

*   正确的做法：`const c1 = 2/3`
*   错误的做法：`const c2 = getNumber()` // 引发构建错误: `getNumber() used as value`

**因为在编译期间自定义函数均属于未知，因此无法用于常量的赋值，但内置函数可以使用，如：`len()`**。

数字型的常量是没有大小和符号的，并且可以使用任何精度而不会导致溢出：

```go
const Ln2 = 0.693147180559945309417232121458176568075500134360255254120680009
const Log2E = 1/Ln2 // this is a precise reciprocal
const Billion = 1e9 // float constant
const hardEight = (1 << 100) >> 97
```

这里的 `<<` 表示左移操作，`1 << 10` 表示将 1 的二进制表示向左移 10 位，也就是由 1 变成了 10000000000，也就是十进制的 1024。同理 `2<<2` 表示将 2 的二进制表示向左移 2 位，也就是由 10 变成了 1000 ，也就是十进制的 8。

常量也允许使用并行赋值的形式：

```go
const beef, two, c = "eat", 2, "veg"

const Monday, Tuesday, Wednesday, Thursday, Friday, Saturday = 1, 2, 3, 4, 5, 6

const (
    Monday, Tuesday, Wednesday = 1, 2, 3
    Thursday, Friday, Saturday = 4, 5, 6
)
```

`const` 同时声明多个常量时，如果省略了值则表示和上面一行的值相同。 例如：

```go
const (
    n1 = 100
    n2
    n3
)
```

上面示例中，常量n1、n2、n3的值都是100。

<p align="center"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/788485f758cb40b092122bd8dace4795~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
