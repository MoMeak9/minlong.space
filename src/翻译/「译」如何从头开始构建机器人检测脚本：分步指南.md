你是否知道，据估计，[所有网络流量中有一半来自机器人](https://www.pcgamer.com/software/ai/bots-now-account-for-half-of-global-internet-traffic-and-bad-bots-nearly-one-third/)？而这些自动流量中有超过一半来自“恶意机器人”。网站不断面临自动机器人的威胁，这些机器人旨在执行恶意活动，如凭证填充攻击、网页抓取、垃圾邮件分发和欺诈。

准确区分这些自动机器人流量与真正的人工流量对于保护网站、用户数据和在线资产至关重要。随着这些机器人不断发展，企业必须采取强有力的措施来有效[检测和缓解机器人攻击](https://fingerprint.com/products/bot-detection/)，并跟上最新的机器人技术。

有许多方法可以识别潜在的机器人活动，无论你是在分析网络和流量模式、用户浏览器和设备信息还是行为模式。这些方法可让你立即采取行动并防止数据泄露、保护用户隐私并确保网站的完整性。

本客户端机器人检测分步指南探讨了识别机器人活动的常用技术。在本教程结束时，你将获得构建基本机器人检测脚本的实践经验，并学习区分人类访问者和恶意机器人并保护你网站的实用方法。

## 了解机器人

机器人是一种自动化程序，可以通过模仿人类行为在互联网上执行任务和交互。这些程序会访问网站和应用并执行预定义的操作，通常采用“无头”模式，没有图形界面。

一方面，机器人可以实现许多合法功能，例如搜索引擎的网络爬取、研究的数据收集、网站性能监控以及自动执行重复的在线任务。

然而，不良行为者也可能将机器人用于恶意目的，例如尝试无数的用户名/密码组合、非法抓取专有数据或受版权保护的内容、发起分布式拒绝服务 (DDoS) 攻击以及传播垃圾邮件或恶意软件。

## 机器人检测的基础知识

[机器人检测策略](https://fingerprint.com/blog/bot-detection/)大致可以分为服务器端和客户端技术，每种技术都利用不同的方法来识别和管理机器人流量。

服务器端检测使用后端来分析 IP 地址、HTTP 标头和会话持续时间等数据。常用方法包括：

- **IP 阻止列表**：根据与恶意活动相关的已知 IP 或机器人网络列表检查用户 IP 地址。
- **速率限制**：监控请求频率，以识别和缓解来自单一来源的异常高流量，这通常表明是机器人造成的。
- **行为分析**：评估一段时间内的访问和交互，以检测偏离人类模式的行为异常。

客户端检测在用户的浏览器中运行，并实时分析用户行为和环境数据。一些客户端方法包括：

- **CAPTCHAs**：通过要求访问者执行对人类来说很简单但对机器人来说很难的任务，将机器人与人类区分开来。
- **浏览器分析**：收集和分析浏览器配置和功能，以识别自动脚本的典型模式或不一致性。
- **行为分析**：监控鼠标移动、击键和交互时间等动作以检测非人类活动。

本指南将重点介绍客户端技术，主要介绍脚本如何分析机器人与网页交互时无意中发出的数据。这些泄漏可能表现为交互模式、浏览器设置或页面布局处理方式的异常。通过检查这些因素，我们可以开发识别潜在机器人的脚本。这种方法可以快速、现场地检测机器人，通过最大限度地减少侵入性检查并保持性能效率来增强用户体验。

## 构建基本的机器人检测脚本

让我们开始为示例应用程序构建一个基本的机器人检测脚本。本教程将使用原生 JavaScript，以便广大受众和各种 Web 环境都可以访问它。我们的应用程序的目标很简单：分析来自访问者浏览器的特定数据，以确定他们是否可能是机器人。我们将通过收集数据、根据常见的机器人模式对其进行分析并在应用程序中发送一条消息来指示脚本是否检测到机器人来实现这一点。此示例将展示客户端脚本如何评估环境信号以进行区分，并且不包括服务器端处理。

**先决条件**

要在本地继续本教程，你必须在计算机上安装[Node.js并使用](https://nodejs.org/en)[Visual Studio Code等代码编辑器。你还可以使用](https://code.visualstudio.com/)[Stackblitz](https://stackblitz.com/)或[CodeSandbox](https://codesandbox.io/)等云开发环境。

### **设置示例 Web 应用程序**

要开始创建我们的机器人检测脚本，我们首先需要一个简单的 Web 应用程序来将其集成到其中。

**1.创建项目结构**

首先为你的项目创建一个新目录。在此目录中，创建以下文件：

- `index.html`：这将是主要的 HTML 文档。
- `script.js`：此 JavaScript 文件将保存我们的机器人检测逻辑。

你的项目目录看起来应该像这样：

```text
bot-detection-app/
|-- index.html
|-- script.js
```

**2.设置 HTML 文件**

打开`index.html`文件并设置基本 HTML 结构，包括`script.js`文件链接。我们将使用[tailwind](https://tailwindcss.com/)进行一些简单的样式设置。以下是一个简单的模板：

```html
<!-- index.html -->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="icon"
      href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%221em%22 font-size=%2280%22>🤖</text></svg>"
    />
    <title>Simple Bot Detection App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="script.js" defer></script>
  </head>
  <body class="bg-gray-100 text-gray-900 min-h-screen pt-20 text-center">
    <h1 class="text-4xl font-bold mb-4">🤖</h1>
    <h1 class="text-2xl font-bold mb-4">Bot Detection Sample Application</h1>
    <div id="result" class="text-xl font-medium"></div>
  </body>
</html>
```

**3. 服务和预览应用程序**

你可以使用简单的 HTTP 服务器在本地运行示例 Web 应用程序并在浏览器中预览它。一种简单的方法是使用 http-server，这是一个易于使用的零配置命令行 HTTP 服务器，非常适合快速提供静态文件。首先，安装软件包：

```bash
npm install -g http-server
```

然后在终端导航到你的项目目录并运行：

```bash
http-server
```

*注意：你也可以将其作为本地项目依赖项安装`npm install http-server`，然后运行它`npx http-server`。*

HTTP 服务器将为你的项目提供服务，使其可在 上使用`http://localhost:8080`。在浏览器中打开此 URL 即可在工作时查看应用程序。

完成这些步骤后，你已设置了一个简单的 Web 应用程序，可以实现机器人检测功能。此设置将使我们能够在本教程的后续部分中专注于收集数据并确定访问者是否可能是机器人。

### **收集并分析访客数据**

在本节中，我们将重点介绍如何收集数据，以便确定访问者是否可能是机器人。我们将收集经常被机器人利用或修改的浏览器特征，这些特征可以作为很好的指标。创建一个新`detectBot`函数，其中包含一个`detectors`对象来存储每个检测到的信号。

```javascript
// script.js

function detectBot() {
  const detectors = {};
}
```

**1. 检测 WebDriver 自动化**

查找机器人检测信号的最简单的地方之一是查看[Navigator对象。此对象是](https://developer.mozilla.org/en-US/docs/Web/API/Navigator)[Window](https://developer.mozilla.org/en-US/docs/Web/API/Window)接口的一部分，表示用户浏览器的状态和身份。它包含有关浏览器本身的信息，包括其版本、运行的操作系统以及浏览器环境的各种功能。

在 navigator 对象中，该`webdriver`属性特别有用，因为它指示浏览器是否由自动化工具（例如 Selenium、Puppeteer 或其他自动化测试框架）控制。与许多其他需要解释或分析的指标不同，这些工具通常将该`navigator.webdriver`属性设置为 true 以指示自动化控制。将此属性添加到`detectors`对象。

```javascript
// script.js

function detectBot() {
  const detectors = {
    webDriver: navigator.webdriver, // Checks if the browser is controlled by automation
  };
}
```

随着我们的进步，我们将向对象添加更多属性`detectors`，以从访客环境的不同方面收集可能表明机器人活动的额外数据。从开始`navigator.webdriver`为识别最明显的自动化交互奠定坚实的基础。

**2. 寻找 Headless Chrome**

该`navigator.userAgent`属性是用于机器人检测的另一个有价值的数据。此用户代理字符串标识浏览器、其版本、底层操作系统，有时还标识有关设备的其他详细信息。查看用户代理可以帮助确定流量是否来自可能用于抓取、自动化或其他脚本活动的常见无头浏览器。添加一个检查用户代理的选项，以查找“Headless”，这是在用于网络上自动化任务的最常用工具中发现的常见值。你还可以使用字符串搜索“PhantomJS”或“Electron”等值来检查其他工具。

```javascript
// script.js

function detectBot() {
  const detectors = {
    webDriver: navigator.webdriver, // Checks if the browser is controlled by automation
    headlessBrowser: navigator.userAgent.includes("Headless"), // Detects headless browsers
  };
}
```

`webdriver`和属性`userAgent`已经可以覆盖相当多的机器人活动，但你分析的指标越多，你的机器人检测就会越准确。特别是因为许多自动化工具添加了试图逃避常见机器人检测技术的功能和设置。让我们继续添加一些更有用的检测器示例。

**3. 检查是否缺少首选语言**

机器人的一个潜在指标是缺少设置语言。该`navigator.languages`属性返回按偏好排序的用户首选语言列表，其中最喜欢的语言（列表中的第一个）也设置为`navigator.language`属性。但是，该`navigator.languages`属性有时会在无头浏览器中返回空字符串。我们将添加此属性的长度作为机器人检测的新信号。

```javascript
// script.js

function detectBot() {
  const detectors = {
    webDriver: navigator.webdriver, // Checks if the browser is controlled by automation
    headlessBrowser: navigator.userAgent.includes("Headless"), // Detects headless browsers
    noLanguages: (navigator.languages?.length || 0) === 0, // Checks if no languages are set, uncommon for regular users
  };
}
```

**4. 评估预期的浏览器功能**

你还可以检查 JavaScript 函数的属性，这些属性有时会被自动化脚本或无头环境更改。机器人可以轻松更改用户代理字符串，因此此检查会查看用户代理的浏览器与该浏览器应具有的功能之间是否存在不匹配。例如，你可以检查函数的长度`eval`并将其与该浏览器的预期长度进行比较。

此检查需要做更多工作，首先检测浏览器，然后比较适当的长度值。让我们添加一个新函数来执行此检查，并将返回的结果用于我们的`inconsistentEval`检测器。

```javascript
// script.js

function detectBot() {
  const detectors = {
    webDriver: navigator.webdriver, // Checks if the browser is controlled by automation
    headlessBrowser: navigator.userAgent.includes("Headless"), // Detects headless browsers
    noLanguages: (navigator.languages?.length || 0) === 0, // Checks if no languages are set, uncommon for regular users
    inconsistentEval: detectInconsistentEval(), // Check for inconsistent eval lengths
  };
}

function detectInconsistentEval() {
  let length = eval.toString().length;
  let userAgent = navigator.userAgent.toLowerCase();
  let browser;

  if (userAgent.indexOf("edg/") !== -1) {
    browser = "edge";
  } else if (
    userAgent.indexOf("trident") !== -1 ||
    userAgent.indexOf("msie") !== -1
  ) {
    browser = "internet_explorer";
  } else if (userAgent.indexOf("firefox") !== -1) {
    browser = "firefox";
  } else if (
    userAgent.indexOf("opera") !== -1 ||
    userAgent.indexOf("opr") !== -1
  ) {
    browser = "opera";
  } else if (userAgent.indexOf("chrome") !== -1) {
    browser = "chrome";
  } else if (userAgent.indexOf("safari") !== -1) {
    browser = "safari";
  } else {
    browser = "unknown";
  }

  if (browser === "unknown") return false;

  return (
    (length === 33 && !["chrome", "opera", "edge"].includes(browser)) ||
    (length === 37 && !["firefox", "safari"].includes(browser)) ||
    (length === 39 && !["internet_explorer"].includes(browser))
  );
}
```

**5. 寻找与自动化相关的属性**

一些自动化工具会向[DOM](https://developer.mozilla.org/en-US/docs/Glossary/DOM)添加特定属性。查找这些属性对于检测特定的自动化工具（如 Selenium）很有用，这些工具可能会以自定义属性的形式留下痕迹。让我们在机器人检测中添加另一个数据点，该数据点获取文档根元素的属性并查找通常与自动化工具相关的属性。

```javascript
// script.js

function detectBot() {
  const detectors = {
    webDriver: navigator.webdriver, // Checks if the browser is controlled by automation
    headlessBrowser: navigator.userAgent.includes("Headless"), // Detects headless browsers
    noLanguages: (navigator.languages?.length || 0) === 0, // Checks if no languages are set, uncommon for regular users
    inconsistentEval: detectInconsistentEval(), // Check for inconsistent eval lengths
    domManipulation: document.documentElement
    .getAttributeNames()
    .some((attr) => ["selenium", "webdriver", "driver"].includes(attr)), // Looks for attributes commonly added by automation tools
  };
}
```

这些只是你可以用来识别机器人的少数示例信号，机器人越复杂，你需要检查的信号就越多。使用这些数据，让我们看看你现在如何检测访问者是否是机器人。

### **检测机器人的存在**

收集到有关访客环境的必要数据点后，下一步就是分析这些信息，以确定访客是否可能是机器人。我们可以循环遍历每个检测器，如果发现机器人的信号，我们将记录标记了哪个检测器，并将机器人判定结果设置为真。

```javascript
// script.js

function detectBot() {
  const detectors = {
    …
  };

  // 1. Stores the detection results and the final verdict
  const detections = {};
  let verdict = { bot: false };

  // 2. Iterates over the detectors and sets the verdict to true if any of them detects bot-like activity
  for (const detectorName in detectors) {
    const detectorResult = detectors[detectorName];
    detections[detectorName] = { bot: detectorResult };
    if (detectorResult) {
      verdict = { bot: true }; // Sets the verdict to true at the first detection of bot-like activity
    }
  }

  // 3. Returns the detection results and the final verdict
  return { detections, verdict };
}
```

新功能`detectBot`：

1. 创建变量来存储机器人检测结果和判决。
2. 循环遍历每个检测器，如果发现机器人信号，则将其添加到检测列表中并将判定结果设置为真。
3. 返回检测列表和最终的机器人裁决。

### **使用机器人检测结果**

此时，你可以根据机器人检测结果决定如何处理访问者。本教程将在页面上显示结果，并在控制台中记录检测和判定。在函数声明后添加以下内容。

```javascript
// script.js

function detectBot() {
	...
}

function detectInconsistentEval() {
	...
}

const { detections, verdict } = detectBot();
document.getElementById('result').innerText = verdict.bot ? 'Bot detected' : 'No bot detected'; // Displays the detection result on the web page
console.log(JSON.stringify(verdict, null, 2)); // Logs the final verdict
console.log(JSON.stringify(detections, null, 2)); // Logs detailed detections
```

### **测试机器人检测**

现在，我们可以访问我们的页面并查看机器人检测脚本的结果。如果你在本地继续操作，请确保 http 服务器正在运行并`http://localhost:8080`在浏览器中访问。如果你使用的是云 IDE，请访问为你的项目提供的预览页面。你应该看到屏幕上显示结果“未检测到机器人”。你还可以在开发者控制台中查看判决结果和详细信息。

![最终机器人检测示例应用程序的屏幕截图](https://fs.lwmc.net/uploads/2024/12/1733396151662-202412051855601.webp)

现在，让我们使用机器人测试脚本。在新终端的根文件夹中，我们将添加 Puppeteer 来测试我们的基本机器人检测。

```bash
npm install puppeteer
```

接下来，创建一个名为的新文件，`bot_test.js`并使用以下代码来运行 Puppeteer 并测试你的应用程序。

```javascript
// bot_test.js

const puppeteer = require("puppeteer");

(async function testBot() {
  const url = "http://localhost:8080";
  const browser = await puppeteer.launch();
  const page = await browser.newPage();
  // Log console messages from the page
  page.on("console", (message) =>
    console.log(`${message.type().toUpperCase()} ${message.text()}`)
  );
  await page.goto(url);
  await page.close();
  await browser.close();
})();
```

在此文件中，我们使用 Puppeteer 库启动无头浏览器并导航到你的本地应用程序。你会注意到有一行显示来自终端页面的任何控制台消息，以查看判决和检测的输出。如果你在云 IDE 中继续操作，请确保使用适当的 URL。

现在脚本已经准备好了，请在新的根终端中运行该`bot_test.js`脚本。

```bash
node bot_test.js
```

或者，你可以使用我们的[无浏览器实例](https://botd-demo.fpjs.sh/)以机器人身份访问面向公众的项目链接。

你将看到控制台日志显示的判决和检测，并应该看到类似于下面的输出，显示检测到了机器人。

```text
LOG {
	"bot": true
}

LOG {
  "webDriver": {
    "bot": true
  },

  "headlessBrowser": {
    "bot": true
  },

  "noLanguages": {
    "bot": false
  },

  "inconsistentEval": {
    "bot": false
  },

  "domManipulation": {
    "bot": false
  }
}
```

本示例教程仅显示机器人检测的结果，但你可以轻松地将判决结果纳入你的应用程序中，以决定如何处理访问者。

## 改善机器人检测

虽然前面提供的基本机器人检测脚本可以作为识别自动流量的介绍，但它自然存在局限性，可能会影响其在更苛刻或多样化的环境中的使用：

**范围有限**：脚本仅检查少数潜在指标，例如`navigator.webdriver`，用户代理内容中的“无头”等。这种狭窄的关注点可能会错过不会触发这些特定检测器的更复杂的机器人。

**工具特异性**：某些检查（例如查找“Headless”）专门用于检测特定类型的自动化工具。虽然这些检查对这些工具有效，但它们无法捕获使用不同工具或定制解决方案（不修改用户代理字符串或使用不同机制）的机器人。

**浏览器依赖性**：所使用的检测技术可能高度依赖于特定浏览器的行为。一些指标可能在实现上存在合理的差异和差异。在更新和不同浏览器之间跟上这些变化会增加复杂性和维护开销。

**动态网络生态系统**：浏览器和机器人技术发展迅速。今天有效的方法明天就可能过时，因为浏览器会更新其隐私和安全功能，机器人操作员也会更新其工具以逃避检测。

### **提高脚本准确性的建议**

为了提高机器人检测机制的准确性和可靠性，请考虑将脚本扩展到基本检查之外。通过结合不同类型的数据点和检测方法，你可以针对各种机器人活动创建更强大的防御措施。例如，集成行为分析（如监控鼠标移动、击键甚至滚动行为）可以帮助识别可能通过更多静态检查的机器人。这些行为信号通常更难让机器人令人信服地模仿，并且可以揭示其交互的非人类特征。

此外，保持检测方法的更新也至关重要。随着浏览器的发展和机器人操作员的技术改进，你的检测策略也必须随之调整。定期更新脚本以与最新的浏览器版本和已知的机器人签名保持一致，可确保你的检测机制能够有效抵御当前和新出现的威胁。

## 使用开源 BotD 库

对于那些希望提高其机器人检测能力但又不想开发和维护复杂的内部系统的人来说，[开源 BotD](https://github.com/fingerprintjs/BotD)机器人检测库提供了一个强大且用户友好的替代方案。

BotD 提供更全面的覆盖范围，包含更多可解决多种机器人行为的[检测技术](https://github.com/fingerprintjs/BotD/tree/main/src/detectors)。作为一个开源库，它可以轻松添加到网站中，以增强对机器人流量的防御能力，从而最大限度地减少通常与检测机器人相关的技术挑战。

## 使用 Fingerprint Pro 最大程度地检测机器人

对于任何面临大量机器人流量或拥有高度敏感服务的人来说，从简单的脚本过渡到 Fingerprint Pro 等综合解决方案可以显著提高站点安全性和数据完整性。虽然开源 BotD 库为机器人检测提供了一个强大的起点，但[Fingerprint Pro 机器人检测](https://fingerprint.com/products/bot-detection/)在此基础上构建。它更进一步，提供了一个更准确、更复杂的系统，旨在满足高流量和高安全性环境的需求。

通过专门的研究团队对机器人行为和特征进行深入和持续的研究，Fingerprint Pro 不断发展以应对最新的机器人技术。这项持续的研究产生了一个最新且高度复杂的检测系统，该系统使用更广泛的信号和先进的检测技术，可以更精确地识别机器人。

Fingerprint Pro Bot Detection 的主要优势之一是它能够检测更广泛的机器人类别。与仅能确定流量是否与机器人相关的简单系统不同，Fingerprint Pro 可以区分好机器人和坏机器人。这种区别对于可能受益于某些类型的机器人（例如搜索引擎爬虫或数据聚合机器人）但仍然需要防范有害或未经授权的机器人的企业至关重要。

[Fingerprint Pro Bot 检测是我们智能信号](https://fingerprint.com/products/smart-signals/)的一部分，可以与其他信号无缝集成，从而实现更细致的决策。这种集成提供了更广泛的用户活动图景，将机器人检测与其他数据点（如虚拟机使用情况或[IP 阻止列表）](https://fingerprint.com/blog/what-is-ip-blocklist-matching/)相结合。